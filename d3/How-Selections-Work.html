<!DOCTYPE html>
<html class="ocks-org do-not-copy">
<meta charset="utf-8">
<title>How Selections Work</title>
<style>

@import url(http://bost.ocks.org/mike/style.css?aea6f0a);
/* added by hanmomhanda */
@import url(http://fonts.googleapis.com/earlyaccess/nanumgothic.css);
/* added by hanmomhanda */

.join,
.link,
.node rect {
  fill: none;
  stroke: #636363;
  stroke-width: 1.5px;
}

.link {
  stroke: #969696;
}

.node rect {
  fill: white;
}

.link path,
.node rect,
.node text,
.join {
  -webkit-transition: all 500ms linear;
  -moz-transition: all 500ms linear;
  -ms-transition: all 500ms linear;
  -o-transition: all 500ms linear;
  transition: all 500ms linear;
}

.node .element rect {
  fill: #bdbdbd;
  stroke: none;
}

.node .null rect {
  fill: none;
  stroke: none;
}

.node .null text {
  fill: #636363;
}

.node .selection rect {
  stroke: #e6550d;
}

.node .data rect {
  stroke: #3182bd;
}

.node .datum rect {
  fill: #d9d9d9;
  stroke: none;
}

.node .code text {
  font-family: monospace;
}

.node .key rect {
  fill: #a1d99b;
  stroke: none;
}

.link .to-key,
.join {
  stroke: #a1d99b;
}

.join {
  stroke-dasharray: 2,2;
}

.link .to-null {
  stroke-dasharray: .5,3.5;
  stroke-linecap: round;
}

.link .from-data {
  stroke: #3182bd;
}

.play circle {
  fill: #fff;
  stroke: #000;
  stroke-width: 3px;
}

.play:hover path {
  fill: #f00;
}

.play.mousedown circle {
  fill: #f00;
}

.play.mousedown path {
  fill: #fff;
}

.play rect {
  fill: none;
  pointer-events: all;
  cursor: pointer;
}

/* added by hanmomhanda */
.ocks-org header,
.ocks-org footer,
.ocks-org aside,
.ocks-org h1,
.ocks-org h2,
.ocks-org h3,
.ocks-org h4,
.ocks-org body {
  font-family: "Nanum Gothic", sans-serif;  
}

.d3-en {
  display: none;
}

.d3-toggle {
  cursor : pointer;
}

/* added by hanmomhanda */

code span {
  -webkit-transition: background 250ms linear;
  -moz-transition: background 250ms linear;
  -ms-transition: background 250ms linear;
  -o-transition: background 250ms linear;
  transition: background 250ms linear;
}

</style>

<header>
  <aside>April 26, 2013</aside>
  <a href="http://bost.ocks.org/mike/" rel="author">Mike Bostock</a>, 원문 : <a href="http://bost.ocks.org/mike/selection/" target="_blank">How Selections Work</a><br/>  
  2014년 11월 11일, 번역 : <a href="https://www.facebook.com/hanmomhanda" rel="author" target="_blank">오명운</a>&nbsp;&nbsp;&nbsp;
  <span class='d3-toggle showEN'>원문 함께 보기</span>&nbsp;&nbsp;&nbsp;<span class='d3-toggle onlyKR'>한글만 보기</span>
</header>

<h1>셀렉션 작동 원리</h1>
<p>&nbsp;</p>
<blockquote class='d3-en'>
  <q>Any sufficiently advanced technology is indistinguishable from magic.</q>
  –Arthur C. Clarke  
</blockquote>

<blockquote>
  <q>충분히 발달한 기술은 마술과 구별이 안된다.</q>
  –Arthur C. Clarke
</blockquote>

<script src="http://d3js.org/d3.v3.min.js"></script>
<script>

var numbers = [4, 5, 18, 23, 42];

var letters = [
  {name: "A", frequency: .08167},
  {name: "B", frequency: .01492},
  {name: "C", frequency: .02780},
  {name: "D", frequency: .04253},
  {name: "E", frequency: .12702}
];

var vowels = [
  {name: "A", frequency: .08167},
  {name: "E", frequency: .12702},
  {name: "I", frequency: .06973},
  {name: "O", frequency: .07507},
  {name: "U", frequency: .02758}
];

var matrix = [
  [ 0,  1,  2,  3],
  [ 4,  5,  6,  7],
  [ 8,  9, 10, 11],
  [12, 13, 14, 15]
];

function name(d) {
  return d.name;
}

var margin = {top: 0, right: 40, bottom: 0, left: 40},
    width = 720,
    step = 100;

function tree(leftRoot, rightRoot, outerHeight) {
  if (arguments.length < 3) outerHeight = rightRoot, rightRoot = null;

  var height = outerHeight - margin.top - margin.bottom;

  var tree = d3.layout.tree()
      .size([height, 1])
      .separation(function() { return 1; });

  var svg = d3.select("body").append("svg")
      .attr("width", width + margin.left + margin.right)
      .attr("height", height + margin.top + margin.bottom)
      .style("margin", "1em 0 1em " + -margin.left + "px");

  var g = svg.selectAll("g")
      .data([].concat(
        leftRoot ? {type: "left", nodes: tree.nodes(leftRoot)} : [],
        rightRoot ? {type: "right", nodes: tree.nodes(rightRoot).map(flip), flipped: true} : []
      ))
    .enter().append("g")
      .attr("class", function(d) { return d.type; })
      .attr("transform", function(d) { return "translate(" + (!!d.flipped * width + margin.left) + "," + margin.top + ")"; });

  var link = g.append("g")
      .attr("class", "link")
    .selectAll("path")
      .data(function(d) { return tree.links(d.nodes); })
    .enter().append("path")
      .attr("class", linkType);

  var node = g.append("g")
      .attr("class", "node")
    .selectAll("g")
      .data(function(d) { return d.nodes; })
    .enter().append("g")
      .attr("class", function(d) { return d.type; });

  node.append("rect");

  node.append("text")
      .attr("dy", ".35em")
      .text(function(d) { return d.name; })
      .each(function(d) { d.width = Math.max(32, this.getComputedTextLength() + 12); })
      .attr("x", function(d) { return d.flipped ? 6 - d.width : 6; });

  node.filter(function(d) { return "join" in d; }).insert("path", "text")
      .attr("class", "join");

  svg.call(reset);

  function flip(d) {
    d.depth *= -1;
    d.flipped = true;
    return d;
  }

  return svg;
}

function linkType(d) {
  return d.target.type.split(/\s+/).map(function(t) { return "to-" + t; })
      .concat(d.source.type.split(/\s+/).map(function(t) { return "from-" + t; }))
      .join(" ");
}

function reset(svg) {
  svg.selectAll("*")
      .style("stroke-opacity", null)
      .style("fill-opacity", null)
      .style("display", null);

  var node = svg.selectAll(".node g")
      .attr("class", function(d) { return d.type; })
      .attr("transform", function(d, i) { return "translate(" + d.depth * step + "," + d.x + ")"; });

  node.select("rect")
      .attr("ry", 6)
      .attr("rx", 6)
      .attr("y", -10)
      .attr("height", 20)
      .attr("width", function(d) { return d.width; })
    .filter(function(d) { return d.flipped; })
      .attr("x", function(d) { return -d.width; });

  node.select(".join")
      .attr("d", d3.svg.diagonal()
        .source(function(d) { return {y: d.width, x: 0}; })
        .target(function(d) { return {y: 88, x: d.join * 24}; })
        .projection(function(d) { return [d.y, d.x]; }));

  svg.selectAll(".link path")
      .attr("class", linkType)
      .attr("d", d3.svg.diagonal()
        .source(function(d) { return {y: d.source.depth * step + (d.source.flipped ? -1 : +1) * d.source.width, x: d.source.x}; })
        .target(function(d) { return {y: d.target.depth * step, x: d.target.x}; })
        .projection(function(d) { return [d.y, d.x]; }));
}

function selectAllAnimation(startRoot, startHeight, endRoot, endHeight) {
  var end = tree(endRoot, endHeight).remove(),
      event = d3.dispatch("start", "middle", "end", "reset"),
      height = +end.attr("height"),
      start = tree(startRoot, startHeight).attr("height", height),
      svg = start.node(),
      offset = (endHeight - startHeight) / 2,
      transform = "translate(" + margin.left + "," + offset + ")";

  var play = start.append("g")
      .attr("class", "play");

  play.append("circle")
      .attr("r", 45)
      .attr("transform", "translate(" + (margin.left + width / 2) + "," + height / 2 + ")");

  play.append("path")
      .attr("d", "M-22,-30l60,30l-60,30z")
      .attr("transform", "translate(" + (margin.left + width / 2) + "," + height / 2 + ")scale(.7)");

  play.append("rect")
      .attr("width", width)
      .attr("height", height)
      .on("mousedown", function() {
        play.classed("mousedown", true);
        d3.select(window).on("mouseup", function() { play.classed("mousedown", false); });
      })
      .on("click", function() {
        resetAll();
        animation();
      });

  end = d3.select(svg.appendChild(end.node().firstChild));
  start = d3.select(svg.firstChild).attr("transform", transform);
  end.selectAll(".array").each(function() { this.parentNode.appendChild(this); }); // mask elements

  var startNodes = start.datum().nodes,
      startElements = startNodes.filter(function(d) { return d.type === "element"; }),
      endNodes = end.datum().nodes,
      endGroups = endNodes.filter(function(d) { return d.type === "array"; });

  resetAll();

  return event;

  function resetAll() {
    start.style("display", "none").call(reset);
    end.style("display", null).call(reset);
    play.style("display", null);
    event.reset();
  }

  function animation() {
    start.call(fadeIn, 150);
    end.style("display", "none");
    play.style("display", "none");
    setTimeout(transition1, 1250);
    event.start();
  }

  function transition1() {
    var t = start.transition()
        .duration(1000 + (startElements.length - 1) * 50)
        .each("end", transition2);

    t.selectAll(".selection,.array,.link")
        .duration(0)
        .style("stroke-opacity", 0)
        .style("fill-opacity", 0);

    t.selectAll(".element")
        .duration(500)
        .delay(function(d, i) { return 500 + i * 50; })
        .attr("transform", function(d, i) { return "translate(" + (d.depth - 1) * step + "," + (endGroups[i].x - offset) + ")"; })
        .attr("class", "array")
      .select("rect")
        .attr("width", function(d, i) { return endGroups[i].width; });

    event.middle();
  }

  function transition2() {
    end.style("display", null)
      .selectAll(".element,.to-element")
        .style("display", "none");

    end.selectAll(".selection,.to-array,.array")
        .call(fadeIn);

    end.transition()
        .duration(500)
        .each("end", transition3);

    event.end();
  }

  function transition3() {
    start.style("display", "none");

    end.selectAll(".element")
        .style("display", null)
        .attr("transform", function(d) { return "translate(" + d.parent.depth * step + "," + d.parent.x + ")"; })
      .transition()
        .duration(500)
        .delay(function(d, i) { return i * 50; })
        .attr("transform", function(d) { return "translate(" + d.depth * step + "," + d.x + ")"; });

    end.selectAll(".to-element")
        .style("display", null)
        .attr("d", d3.svg.diagonal()
          .source(function(d) { return {y: d.source.depth * step + d.source.width, x: d.source.x}; })
          .target(function(d, i) { return {y: d.source.depth * step + d.source.width, x: d.source.x}; })
          .projection(function(d) { return [d.y, d.x]; }))
      .transition()
        .duration(500)
        .delay(function(d, i) { return i * 50; })
        .attr("d", d3.svg.diagonal()
          .source(function(d) { return {y: d.source.depth * step + d.source.width, x: d.source.x}; })
          .target(function(d, i) { return {y: d.target.depth * step, x: d.target.x}; })
          .projection(function(d) { return [d.y, d.x]; }));

    end.transition()
        .duration(2000)
        .each("end", resetAll);
  }
}

function updateAnimation(leftRoot, rightRoot, endRoot, outerHeight) {
  var start = tree(leftRoot, rightRoot, outerHeight),
      left = d3.select(start.node().firstChild),
      right = d3.select(left.node().nextSibling),
      end = tree(endRoot, outerHeight).remove(),
      height = +start.attr("height");

  end = d3.select(start.node().appendChild(end.node().firstChild));
  left.selectAll(".element").each(function() { this.parentNode.appendChild(this); }); // mask keys
  right.selectAll(".datum").each(function() { this.parentNode.appendChild(this); }); // mask keys
  start.node().appendChild(left.node());
  start.node().appendChild(right.node());

  var leftKeys = left.datum().nodes.filter(function(d) { return d.type === "key"; }),
      rightKeys = right.datum().nodes.filter(function(d) { return d.type === "key"; }),
      endElements = end.datum().nodes.filter(function(d) { return d.parent && d.parent.type === "array"; });

  leftKeys.forEach(function(l, i) {
    if ("join" in l) {
      rightKeys[i + l.join].joined = true;
      endElements[i + l.join].start = l.parent;
      l.parent.end = endElements[i + l.join];
    }
  });

  leftKeys.forEach(function(l, i) {
    if (!("join" in l)) endElements.some(function(e) {
      if (!e.start) {
        e.start = l.parent;
        l.parent.end = e;
        return true;
      }
    });
  });

  var play = start.append("g")
      .attr("class", "play");

  play.append("circle")
      .attr("r", 45)
      .attr("transform", "translate(" + (margin.left + width / 2) + "," + height / 2 + ")");

  play.append("path")
      .attr("d", "M-22,-30l60,30l-60,30z")
      .attr("transform", "translate(" + (margin.left + width / 2) + "," + height / 2 + ")scale(.7)");

  play.append("rect")
      .attr("width", width)
      .attr("height", height)
      .on("mousedown", function() {
        play.classed("mousedown", true);
        d3.select(window).on("mouseup", function() { play.classed("mousedown", false); });
      })
      .on("click", function() {
        resetAll();
        animation();
      });

  resetAll();

  function resetAll() {
    play.style("display", null);
    left.style("display", "none").call(reset);
    right.style("display", "none").call(reset);
    right.selectAll(".key").classed("joined", function(d) { return d.joined; });
    right.selectAll(".datum").classed("joined", function(d) { return d.children[0].joined; });
    right.selectAll(".to-key").classed("joined", function(d) { return d.target.joined; });
    end.call(reset);
  }

  function animation() {
    play.style("display", "none");
    end.style("display", "none");
    left.call(fadeIn);
    right.call(fadeIn);
    setTimeout(transition1, 1250);
  }

  function transition1() {
    left.selectAll(".key").filter(function(d) { return !("join" in d); })
        .style("stroke-opacity", 0)
        .style("fill-opacity", 0);

    left.selectAll(".to-key").filter(function(d) { return !("join" in d.target); })
        .style("stroke-opacity", 0)
        .style("fill-opacity", 0);

    left.selectAll(".element").filter(function(d) { return !("join" in d.children[0]); })
        .style("stroke-opacity", 0)
        .style("fill-opacity", 0);

    left.selectAll(".to-element").filter(function(d) { return !("join" in d.target.children[0]); })
        .style("stroke-opacity", 0)
        .style("fill-opacity", 0);

    right.selectAll(".link > :not(.joined),.node > :not(.joined)")
        .style("stroke-opacity", 0)
        .style("fill-opacity", 0);

    end.style("display", null);

    end.selectAll(".datum,.to-datum")
        .style("display", "none");

    end.selectAll(".element,.null")
        .attr("transform", function(d, i) { return "translate(" + d.depth * step + "," + d.start.x + ")"; });

    end.selectAll(".to-element,.to-null")
        .attr("d", d3.svg.diagonal()
          .source(function(d) { return {y: d.source.depth * step + d.source.width, x: d.source.x}; })
          .target(function(d) { return {y: d.target.depth * step, x: d.target.start.x}; })
          .projection(function(d) { return [d.y, d.x]; }));

    setTimeout(transition2, 500);
  }

  function transition2() {
    left.selectAll(".element").transition()
        .duration(500)
        .attr("transform", function(d, i) { return "translate(" + d.depth * step + "," + d.end.x + ")"; });

    left.selectAll(".key").transition()
        .duration(500)
        .attr("transform", function(d, i) { return "translate(" + d.depth * step + "," + d.parent.end.x + ")"; });

    left.selectAll(".to-element").transition()
        .duration(500)
        .attr("d", d3.svg.diagonal()
          .source(function(d) { return {y: d.source.depth * step + d.source.width, x: d.source.x}; })
          .target(function(d) { return {y: d.target.depth * step, x: d.target.end.x}; })
          .projection(function(d) { return [d.y, d.x]; }));

    left.selectAll(".to-key").transition()
        .duration(500)
        .attr("d", d3.svg.diagonal()
          .source(function(d) { return {y: d.source.depth * step + d.source.width, x: d.source.end.x}; })
          .target(function(d) { return {y: d.target.depth * step, x: d.target.parent.end.x}; })
          .projection(function(d) { return [d.y, d.x]; }));

    left.selectAll(".join").transition()
        .duration(500)
        .attr("d", d3.svg.diagonal()
          .source(function(d) { return {y: d.width, x: 0}; })
          .target(function(d) { return {y: 88, x: 0}; })
          .projection(function(d) { return [d.y, d.x]; }));

    end.selectAll(".element,.null").transition()
        .duration(500)
        .attr("transform", function(d, i) { return "translate(" + d.depth * step + "," + d.x + ")"; });

    end.selectAll(".to-element,.to-null").transition()
        .duration(500)
        .attr("d", d3.svg.diagonal()
          .source(function(d) { return {y: d.source.depth * step + d.source.width, x: d.source.x}; })
          .target(function(d) { return {y: d.target.depth * step, x: d.target.x}; })
          .projection(function(d) { return [d.y, d.x]; }));

    setTimeout(transition3, 500);
  }

  function transition3() {
    var offset = 12;

    left.selectAll(".join").transition()
        .duration(500)
        .attr("d", d3.svg.diagonal()
          .source(function(d) { return {y: d.width, x: 0}; })
          .target(function(d) { return {y: d.width, x: 0}; })
          .projection(function(d) { return [d.y, d.x]; }));

    left.selectAll(".to-key")
        .attr("class", "from-element to-datum");

    right.selectAll(".to-key").transition()
        .duration(500)
        .attr("d", d3.svg.diagonal()
          .source(function(d) { return {y: (d.source.depth - 2) * step + offset - d.source.width, x: d.source.x}; })
          .target(function(d) { return {y: (d.source.depth - 2) * step + offset - d.source.width, x: d.source.x}; })
          .projection(function(d) { return [d.y, d.x]; }));

    right.selectAll(".key").transition()
        .duration(500)
        .attr("transform", function(d, i) { return "translate(" + ((d.depth - 1) * step + offset) + "," + d.x + ")"; });

    right.selectAll(".datum").transition()
        .duration(500)
        .attr("transform", function(d, i) { return "translate(" + ((d.depth - 2) * step + offset) + "," + d.x + ")"; });

    setTimeout(resetAll, 2000);
  }
}

function exitAnimation(leftRoot, rightRoot, endRoot, outerHeight) {
  var start = tree(leftRoot, rightRoot, outerHeight),
      left = d3.select(start.node().firstChild),
      right = d3.select(left.node().nextSibling),
      end = tree(endRoot, outerHeight).remove(),
      height = +start.attr("height");

  end = d3.select(start.node().appendChild(end.node().firstChild));
  start.node().appendChild(left.node());
  start.node().appendChild(right.node());

  var play = start.append("g")
      .attr("class", "play");

  play.append("circle")
      .attr("r", 45)
      .attr("transform", "translate(" + (margin.left + width / 2) + "," + height / 2 + ")");

  play.append("path")
      .attr("d", "M-22,-30l60,30l-60,30z")
      .attr("transform", "translate(" + (margin.left + width / 2) + "," + height / 2 + ")scale(.7)");

  play.append("rect")
      .attr("width", width)
      .attr("height", height)
      .on("mousedown", function() {
        play.classed("mousedown", true);
        d3.select(window).on("mouseup", function() { play.classed("mousedown", false); });
      })
      .on("click", function() {
        resetAll();
        animation();
      });

  resetAll();

  function resetAll() {
    play.style("display", null);
    left.style("display", "none").call(reset);
    right.style("display", "none").call(reset);
    end.call(reset);
  }

  function animation() {
    play.style("display", "none");
    end.style("display", "none");
    left.call(fadeIn);
    right.call(fadeIn);
    setTimeout(transition1, 1250);
  }

  function transition1() {
    end.style("display", null);

    left
        .style("stroke-opacity", 0)
        .style("fill-opacity", 0);

    right
        .style("stroke-opacity", 0)
        .style("fill-opacity", 0);

    setTimeout(resetAll, 2000);
  }
}

function enterAnimation(leftRoot, rightRoot, endRoot, outerHeight) {
  var start = tree(leftRoot, rightRoot, outerHeight),
      left = d3.select(start.node().firstChild),
      right = d3.select(left.node().nextSibling),
      end = tree(endRoot, outerHeight).remove(),
      height = +start.attr("height");

  start.node().appendChild(left.node());
  start.node().appendChild(right.node());
  end = d3.select(start.node().appendChild(end.node().firstChild));

  var leftKeys = left.datum().nodes.filter(function(d) { return d.type === "key"; }),
      rightKeys = right.datum().nodes.filter(function(d) { return d.type === "key"; });

  leftKeys.forEach(function(l, i) {
    if ("join" in l) {
      rightKeys[i + l.join].joined = true;
    }
  });

  var play = start.append("g")
      .attr("class", "play");

  play.append("circle")
      .attr("r", 45)
      .attr("transform", "translate(" + (margin.left + width / 2) + "," + height / 2 + ")");

  play.append("path")
      .attr("d", "M-22,-30l60,30l-60,30z")
      .attr("transform", "translate(" + (margin.left + width / 2) + "," + height / 2 + ")scale(.7)");

  play.append("rect")
      .attr("width", width)
      .attr("height", height)
      .on("mousedown", function() {
        play.classed("mousedown", true);
        d3.select(window).on("mouseup", function() { play.classed("mousedown", false); });
      })
      .on("click", function() {
        resetAll();
        animation();
      });

  resetAll();

  function resetAll() {
    play.style("display", null);
    left.style("display", "none").call(reset);
    right.style("display", "none").call(reset);
    right.selectAll(".key").classed("joined", function(d) { return d.joined; });
    right.selectAll(".datum").classed("joined", function(d) { return d.children[0].joined; });
    right.selectAll(".to-key").classed("joined", function(d) { return d.target.joined; });
    end.call(reset);
  }

  function animation() {
    play.style("display", "none");
    end.style("display", "none");
    left.call(fadeIn);
    right.call(fadeIn);
    setTimeout(transition1, 1250);
  }

  function transition1() {
    end.style("display", null);

    end.selectAll(".element,.datum,.to-datum")
        .style("stroke-opacity", 0)
        .style("fill-opacity", 0);

    left.selectAll(".element,.to-element,.key,.to-key")
        .style("stroke-opacity", 0)
        .style("fill-opacity", 0);

    right.selectAll(".array,.to-array,.data,.to-function,.to-datum,.joined")
        .style("stroke-opacity", 0)
        .style("fill-opacity", 0);

    setTimeout(transition2, 750);
  }

  function transition2() {
    var offset = 12;

    right.selectAll(".key:not(.joined)").transition()
        .duration(500)
        .attr("transform", function(d, i) { return "translate(" + ((d.depth - 2) * step + offset) + "," + d.x + ")"; });

    right.selectAll(".datum:not(.joined)").transition()
        .duration(500)
        .attr("transform", function(d, i) { return "translate(" + ((d.depth - 2) * step + offset) + "," + d.x + ")"; });

    right.selectAll(".to-key:not(.joined)").transition()
        .duration(500)
        .attr("d", d3.svg.diagonal()
          .source(function(d) { return {y: (d.source.depth - 2) * step + offset - d.source.width, x: d.source.x}; })
          .target(function(d) { return {y: (d.source.depth - 3) * step + offset - d.source.width, x: d.source.x}; })
          .projection(function(d) { return [d.y, d.x]; }));

    setTimeout(transition3, 500);
  }

  function transition3() {
    right.selectAll(".to-key:not(.joined)")
        .style("stroke-opacity", 0);

    end.selectAll(".element,.datum,.to-datum")
        .style("stroke-opacity", 1)
        .style("fill-opacity", 1);

    setTimeout(resetAll, 2000);
  }
}

function fadeIn(selection, delay) {
  selection
      .style("display", null)
      .style("stroke-opacity", 0)
      .style("fill-opacity", 0)
    .transition()
      .duration(delay || 0)
      .style("stroke-opacity", 1)
      .style("fill-opacity", 1);
}

</script>

<p class='d3-en'>In the past I have <a href="../d3/workshop/">presented</a> <a href="../join/">simplified</a> <a href="http://mbostock.github.io/d3/tutorial/circle.html">descriptions</a> of <a href="http://d3js.org">D3</a>’s selections, providing only enough detail to get started. This article takes a more comprehensive approach; rather than saying how to <i>use</i> <a href="https://github.com/mbostock/d3/wiki/Selections">selections</a>, I will explain how selections are <i>implemented</i>. This may take longer to read, but it should dispel any magic and help you master data-driven documents.</p>
</p>

<p>예전에 <a href="http://d3js.org">D3</a>의 <a href="https://github.com/mbostock/d3/wiki/Selections">셀렉션</a>에 대해, D3를 시작하는 데 필요한 정도로만 <a href="http://bost.ocks.org/mike/join/">단순</a>하게 <a href="http://mbostock.github.io/d3/tutorial/circle.html">설명</a>한 <a href="http://bost.ocks.org/mike/d3/workshop/">프리젠테이션</a>을 준비한 적이 있었다. 이 글에서는 단순히 셀렉션의 <i>사용 방법</i>을 다루기 보다는, <i>구현 방법</i>을 포함하여 셀렉션을 더 종합적으로 접근해서 다루고자 한다. 그래서 읽는 데 오래 걸릴 수는 있겠지만, D3가 마술 같다는 느낌을 떨쳐 내고, 데이터 기반 문서(Data-Driven Documents, D3)를 제대로 마스터 하는 데 분명 도움이 될 것이다.

<p class='d3-en'>The structure of this article may at first seem arbitrary. It describes the internal workings of selections rather than the design motivations, so you may wonder why such mechanisms are needed. This is simply because it is easier to lay all the pieces out first before explaining how everything works in tandem. By the time you read to the end, the intent of the design as well as its function should be clear.</p>

<p>이 글의 구조는 처음보면 뭔가 정돈되지 않고 멋대로 나열되어 있는 것처럼 보일 수도 있을 것이다. 이 글은 셀렉션을 이렇게 설계한 이유에 대한 내용 보다는 셀렉션의 내부 작동 방식에 대해 설명하고 있기 때문에, 읽다보면 왜 이런 메커니즘이 필요했는 지 궁금할 수 있다. 먼저 필요한 요소들을 죄다 꺼내 놓은 다음에 각 요소가 어떻게 동작하는 지 설명하는 것이 더 쉬우므로, 끝까지 읽고 나면 작동 원리 뿐 아니라 설계의 의도까지도 명확하게 이해할 수 있을 것이다.

<p class='d3-en'>D3 is a visualization library, so this article incorporates visual explanations to accompany the text. In subsequent diagrams, the left side of the diagram will show the structure of selections, while the right side will show the structure of data:</p>

<p>D3는 시각화 라이브러리다. 따라서, 텍스트에 시각적인 설명을 포함해서 이야기를 풀어갈 것이다. 설명에 나오는 다이어그램에서, 아래와 같이 왼쪽은 셀렉션의 구조를 보여주고, 오른쪽은 데이터의 구조를 보여줄 것이다:

<p><svg width="740" height="120" style="margin:1em -10px;">
  <g transform="translate(9.5,9.5)">
    <rect fill="#eee" stroke="#ccc" stroke-dasharray="2,2" width="355" height="100"/>
    <rect fill="#eee" stroke="#ccc" stroke-dasharray="2,2" x="365" width="355" height="100"/>
    <rect fill="#a1d99b" fill-opacity=".8" stroke="#71a76c" stroke-dasharray="2,2" y="10" x="300" width="120" height="80"/>
    <text x="178" text-anchor="middle" y="50" dy=".35em">왼쪽은 셀렉션의 구조</text>
    <text x="360" text-anchor="middle" y="50" dy=".35em">연결부</text>
    <text x="543" text-anchor="middle" y="50" dy=".35em">오른쪽은 데이터의 구조</text>
  </g>
</svg>

<p class='d3-en'>Rounded rectangles such as <span style="display:inline-block;position:relative;width:55px;"><svg style="position:absolute;top:-17px;" class="node" width="55" height="22"><g transform="translate(1,1)" class="datum"><rect rx="6" ry="6" width="53" height="20"/><text x="26" y="10" dy=".35em" text-anchor="middle">thing</text></g></svg></span> indicate JavaScript objects of various types, ranging from literal objects (<code>{foo: 16}</code>), primitive values (<code>"hello"</code>), arrays of numbers (<code>[1, 2, 3]</code>) to DOM elements. Certain special object types are colored, including <span style="display:inline-block;position:relative;width:55px;"><svg style="position:absolute;top:-17px;" class="node" width="55" height="22"><g transform="translate(1,1)" class="selection"><rect rx="6" ry="6" width="53" height="20"/><text x="26" y="10" dy=".35em" text-anchor="middle">selection</text></g></svg></span>, <span style="display:inline-block;position:relative;width:55px;"><svg style="position:absolute;top:-17px;" class="node" width="55" height="22"><g transform="translate(1,1)" class="array"><rect rx="6" ry="6" width="53" height="20"/><text x="26" y="10" dy=".35em" text-anchor="middle">array</text></g></svg></span>, and <span style="display:inline-block;position:relative;width:55px;"><svg style="position:absolute;top:-17px;" class="node" width="55" height="22"><g transform="translate(1,1)" class="element"><rect rx="6" ry="6" width="53" height="20"/><text x="26" y="10" dy=".35em" text-anchor="middle">element</text></g></svg></span>. References from one object to another are indicated with connecting lines (<span style="display:inline-block;position:relative;width:55px;"><svg style="position:absolute;top:-17px;" class="link" width="55" height="22"><line x1="1" x2="54" y1="11" y2="11"/></svg></span>). For example, an array containing the number 42 looks like:</p>

<p>
<span style="display:inline-block;position:relative;width:55px;"><svg style="position:absolute;top:-17px;" class="node" width="55" height="22"><g transform="translate(1,1)" class="datum"><rect rx="6" ry="6" width="53" height="20"/><text x="26" y="10" dy=".35em" text-anchor="middle">thing</text></g></svg></span>처럼 모서리가 둥근 네모로 표시된 것은 리터럴 객체(<code>{foo: 16}</code>), 원시 데이터 값(<code>"hello"</code>), 숫자 배열(<code>[1, 2, 3]</code>)에서 DOM 문서요소까지 다양한 자바스크립트의 객체를 나타낸다. <span style="display:inline-block;position:relative;width:55px;"><svg style="position:absolute;top:-17px;" class="node" width="55" height="22"><g transform="translate(1,1)" class="selection"><rect rx="6" ry="6" width="53" height="20"/><text x="26" y="10" dy=".35em" text-anchor="middle">셀렉션</text></g></svg></span>, <span style="display:inline-block;position:relative;width:55px;"><svg style="position:absolute;top:-17px;" class="node" width="55" height="22"><g transform="translate(1,1)" class="array"><rect rx="6" ry="6" width="53" height="20"/><text x="26" y="10" dy=".35em" text-anchor="middle">배열</text></g></svg></span>, <span style="display:inline-block;position:relative;width:85px;"><svg style="position:absolute;top:-17px;" class="node" width="85" height="22"><g transform="translate(1,1)" class="element"><rect rx="6" ry="6" width="83" height="20"/><text x="43" y="10" dy=".35em" text-anchor="middle">DOM요소</text></g></svg></span> 처럼 특별한 객체는 색깔을 넣어 표시했다. 한 객체에서 다른 객체로의 참조는 연결선으로 표시했다. 예를 들어, 42라는 숫자 하나를 원소로 가지는 배열은 다음과 같이 표시한다:

<pre><code>var array = [42];</code></pre>

<script>

tree(
  {type: "array", name: "array", children: [
    {type: "datum", name: "42"}
  ]},
  24 * 1
);

</script>

<p class='d3-en'>Wherever possible, the code that generates the given selection appears immediately above the diagram. Opening your browser’s JavaScript console and creating selections interactively is a great way to test your understanding of the text!</p>

<p>설명에 나오는 셀렉션을 만들어내는 코드는 다이어그램의 바로 위에 배치했다. 브라우저의 자바스크립트 콘솔을 열고 직접 셀렉션을 생성하고 테스트 하면서 읽으면 훨씬 이해하기 쉬울 것이다!

<p class='d3-en'>Let’s begin.</p>

<p>이제 본격적으로 시작해 보자.

<h2><a href="#subclass" name="subclass">#</a>배열의 서브클래스</h2>

<aside>자바스크립트는 아직 배열의 서브클래스를 직접적으로 지원하지는 않는다. <a href="http://perfectionkills.com/how-ecmascript-5-still-does-not-allow-to-subclass-an-array/">프로토타입 체인 주입</a>을 통해 배열의 서브클래스를 얻을 수 있다.</aside>

<p class='d3-en'>You were probably told that selections are arrays of DOM elements. False. For one, selections are a <i>subclass</i> of array; this subclass provides methods to manipulate selected elements, such as setting <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-attr">attributes</a> and <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-style">styles</a>. Selections inherit native array methods as well, such as <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/forEach">array.forEach</a> and <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/forEach">array.map</a>. However, you won’t often use native methods as D3 provides convenient alternatives, such as <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-each">selection.each</a>. (A few native methods are overridden to adapt their behavior to selections, namely <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-filter">selection.filter</a> and <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-sort">selection.sort</a>.)</p>

<p>여러분은 셀렉션이 DOM 문서요소의 배열이라는 말을 들어봤을 것이다. 한마디로 아니올시다. 셀렉션은 배열의 <i>서브클래스</i>다. 셀렉트된 요소의 <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-attr">속성</a>이나 <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-style">스타일</a>을 설정할 수 있는 메서드를 이 서브클래스가 제공한다. 셀렉션은 <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/forEach">array.forEach</a> 와 <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/map">array.map</a> 과 같은 네이티브 메서드도 상속받아 지원하지만, D3가 <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-each">selection.each</a> 와 같은 편리한 대체 메서드를 제공하기 때문에, 네이티브 메서드를 직접 사용할 일은 별로 없을 것이다(<a href="https://github.com/mbostock/d3/wiki/Selections#wiki-filter">selection.filter</a> 와 <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-sort">selection.sort</a> 같은 몇 가지 네이티브 메서드는 재정의 되었다).

<h2><a href="#group" name="group">#</a>문서요소 그룹핑</h2>

<p class='d3-en'>Another reason selections aren’t literally arrays of elements is that they are <i>arrays of arrays</i> of elements: a selection is an array of groups, and each group is an array of elements. For example, <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-d3_select">d3.select</a> returns a selection with one group containing the selected element:</p>

<p>셀렉션이 문서요소의 배열이라는 말이 틀린 또 하나의 이유는, 셀렉션은 문서요소의 배열이 아니라 문서요소의 배열의 배열이라는 점이다: 셀렉션은 그룹의 배열인데, 각 그룹은 문서요소의 배열이다. 예를 들어, <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-d3_select">d3.select</a> 는 선택된 문서요소를 원소로 하는 한 개의 그룹을 원소로 하는 배열을 반환한다:

<pre><code>var selection = d3.select("body");</code></pre>

<script>

tree(
  {type: "selection", name: "selection", children: [
    {type: "array", name: "group", children: [
      {type: "element", name: "body"}
    ]}
  ]},
  24 * 1
);

</script>

<aside>윈도우용 크롬 브라우저에서는 <span style="font-family:'Lucida Grande';">CTRL+SHIFT+J</span> 를 누르면 개발자 도구의 콘솔을 열 수 있다.</aside>

<p class='d3-en'>In the <a href="https://developers.google.com/chrome-developer-tools/docs/console#opening_the_console">JavaScript console</a>, try running this command and inspecting the group as <code>selection[0]</code> and the node as <code>selection[0][0]</code>. While accessing a node directly is supported by D3’s API, for reasons that will soon be apparent it is more common to use <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-node">selection.node</a>.</p>

<p><a href="https://developers.google.com/chrome-developer-tools/docs/console#opening_the_console">자바스크립트 콘솔</a>에서 아래의 명령을 실행하고 <code>selection[0]</code>으로 그룹을, <code>selection[0][0]</code>으로 노드를 검사해보자. D3 API로 노드에 직접 접근할 수도 있지만, <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-node">selection.node</a>를 사용하는 것이 훨씬 더 나은 이유를 곧 알게될 것이다.

<p class='d3-en'>Likewise, <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-d3_selectAll">d3.selectAll</a> returns a selection with one group and any number of elements:</p>

<p>마찬가지로, <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-d3_selectAll">d3.selectAll</a>은 여러 개의 문서요소를 원소로 하는 한 개의 그룹 배열을 원소로 하는 배열을 반환한다:

<pre><code>d3.selectAll("h2");</code></pre>

<aside>셀렉션은 배열의 서브클래스이지만, 그룹은 그냥 일반 배열이다.</aside>

<script>

tree(
  {type: "selection", name: "selection", children: [
    {type: "array", name: "group", children: [
      {type: "element", name: "h2"},
      {type: "element", name: "h2"},
      {type: "element", name: "h2"},
      {type: "element", name: "h2"}
    ]}
  ]},
  24 * 4
);

</script>

<p class='d3-en'>Selections returned by d3.select and d3.selectAll have exactly one group. The only way for you to obtain a selection with multiple groups is <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-selectAll">selection.selectAll</a>. For example, if you select all table rows and then select the rows’ cells, you’ll get a group of sibling cells for each row:</p>

<p>d3.select나 d3.selectAll은 정확히 한 개의 그룹 배열을 반환한다. 여러 개의 그룹 배열을 반환하는 유일한 방법은 <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-selectAll">selection.selectAll</a>을 사용하는 것이다. 예를 들어, 테이블의 모든 행을 셀렉트하고, 각 행의 셀을 셀렉트하면, 각 행의 셀을 원소로 하는 여러 개의 그룹을 원소로 하는 배열을 반환 받게 된다:

<pre><code>d3.<span id="select-all-1-1">selectAll("tr")</span>.<span id="select-all-1-2">selectAll("td")</span>;</code></pre>

<aside>그림에 나오는 셀렉션의 그룹은 모두 똑같이 네 개의 원소를 가지고 있지만, 일반적으로 셀렉션의 각 그룹은 각기 다른 갯수의 원소를 가질 수 있다. 뿐만아니라 그룹은 심지어 비어있을 수도 있다!(역자 주 : 원문에는 똑같이 4개 씩의 td를 가지는 4개의 tr에 대한 그림으로 설명하고 있으나, 4개의 tr과 4개의 td로 인해 잘못된 이해를 유발할 수 있어 여기 설명대로 각 그룹이 각기 다른 갯수의 원소를 가질 수 있음을 보여주기 위해 그림을 수정하였음)</aside>

<script>

selectAllAnimation(
  {type: "selection", name: "selection", children: [
    {type: "array", name: "group", children: [
      {type: "element", name: "tr"},
      {type: "element", name: "tr"},
      {type: "element", name: "tr"},
      {type: "element", name: "tr"}
    ]}
  ]},
  24 * 4,
  {type: "selection", name: "selection", children: [
    {type: "array", name: "group", children: [
      {type: "element", name: "td"},            
      {type: "element", name: "td"}
    ]},
    {type: "array", name: "group", children: [
      {type: "element", name: "td"},
      {type: "element", name: "td"},
      {type: "element", name: "td"},
      {type: "element", name: "td"},
      {type: "element", name: "td"},
      {type: "element", name: "td"}
    ]},
    {type: "array", name: "group", children: [
      {type: "element", name: "td"},      
      {type: "element", name: "td"},
      {type: "element", name: "td"}
    ]},
    {type: "array", name: "group", children: [
      {type: "element", name: "td"},
      {type: "element", name: "td"},
      {type: "element", name: "td"},
      {type: "element", name: "td"},
      {type: "element", name: "td"}
    ]}
  ]},
  24 * 16
).on("start", function() {
  d3.select("#select-all-1-1").style("background", "#ff0");
}).on("middle", function() {
  d3.select("#select-all-1-1").style("background", null);
}).on("end", function() {
  d3.select("#select-all-1-2").style("background", "#ff0");
}).on("reset", function() {
  d3.selectAll("#select-all-1-1,#select-all-1-2").style("background", null);
});

</script>

<p class='d3-en'>With selectAll, <b>every element in the old selection becomes a group in the new selection</b>; each group contains an old element’s matching descendant elements. So, if each table cell contained a <a href="https://developer.mozilla.org/en-US/docs/HTML/Element/span">span</a> element, and you called selectAll a third time, you’d get a selection with sixteen groups:</p>

<p><code>selection</code>.selectAll을 쓰면, <b>selectAll 메서드를 호출하는 원래 셀렉션인 <code>selection</code>에 있던 모든 최말단 문서요소 들이 <code>selection</code>.selectAll에 의해 반환되는 새로운 셀렉션의 그룹이 된다</b>. 예를 들어, 만약 앞의 테이블 셀렉션 예제에서 각 셀이 <a href="https://developer.mozilla.org/en-US/docs/HTML/Element/span">span</a> 문서요소를 가지고 있어서, 다음과 같이 selectAll을 한 번 더 호출하면, 두 번째 selectAll의 호출 결과로 나왔던 16개의 td 가 새로운 셀렉션에서는 아래와 같이 16개의 그룹이 된다:

<pre><code>d3.selectAll("tr").<span id="select-all-2-1">selectAll("td")</span>.<span id="select-all-2-2">selectAll("span")</span>;</code></pre>

<script>

selectAllAnimation(
  {type: "selection", name: "selection", children: [
    {type: "array", name: "group", children: [
      {type: "element", name: "td"},
      {type: "element", name: "td"},
      {type: "element", name: "td"},
      {type: "element", name: "td"}
    ]},
    {type: "array", name: "group", children: [
      {type: "element", name: "td"},
      {type: "element", name: "td"},
      {type: "element", name: "td"},
      {type: "element", name: "td"}
    ]},
    {type: "array", name: "group", children: [
      {type: "element", name: "td"},
      {type: "element", name: "td"},
      {type: "element", name: "td"},
      {type: "element", name: "td"}
    ]},
    {type: "array", name: "group", children: [
      {type: "element", name: "td"},
      {type: "element", name: "td"},
      {type: "element", name: "td"},
      {type: "element", name: "td"}
    ]}
  ]},
  24 * 16,
  {type: "selection", name: "selection", children: [
    {type: "array", name: "group", children: [{type: "element", name: "span"}]},
    {type: "array", name: "group", children: [{type: "element", name: "span"}]},
    {type: "array", name: "group", children: [{type: "element", name: "span"}]},
    {type: "array", name: "group", children: [{type: "element", name: "span"}]},
    {type: "array", name: "group", children: [{type: "element", name: "span"}]},
    {type: "array", name: "group", children: [{type: "element", name: "span"}]},
    {type: "array", name: "group", children: [{type: "element", name: "span"}]},
    {type: "array", name: "group", children: [{type: "element", name: "span"}]},
    {type: "array", name: "group", children: [{type: "element", name: "span"}]},
    {type: "array", name: "group", children: [{type: "element", name: "span"}]},
    {type: "array", name: "group", children: [{type: "element", name: "span"}]},
    {type: "array", name: "group", children: [{type: "element", name: "span"}]},
    {type: "array", name: "group", children: [{type: "element", name: "span"}]},
    {type: "array", name: "group", children: [{type: "element", name: "span"}]},
    {type: "array", name: "group", children: [{type: "element", name: "span"}]},
    {type: "array", name: "group", children: [{type: "element", name: "span"}]}
  ]},
  24 * 16
).on("start", function() {
  d3.select("#select-all-2-1").style("background", "#ff0");
}).on("middle", function() {
  d3.select("#select-all-2-1").style("background", null);
}).on("end", function() {
  d3.select("#select-all-2-2").style("background", "#ff0");
}).on("reset", function() {
  d3.selectAll("#select-all-2-1,#select-all-2-2").style("background", null);
});

</script>

<aside>자바스크립트 콘솔에서 그룹의 부모 노드를 확인해보자. 이 주제에 대한 상세한 내용은 <a href="http://bost.ocks.org/mike/nest/">중첩 셀렉션</a>를 참조한다.</aside>

<p class='d3-en'>Each group has a <code>parentNode</code> property which stores the shared parent of all the group’s elements. The parent node is set when the group is created. Thus, if you call <code>d3.selectAll("tr")&#8203;.selectAll("td")</code>, the returned selection contains groups of td elements, whose parents are tr elements. For selections returned by d3.select and d3.selectAll, the parent element is the <a href="https://developer.mozilla.org/en-US/docs/DOM/document.documentElement">document element</a>.</p>

<p>각 그룹은 그룹 내의 모든 원소의 공통적인 부모 노드를 저장하는 <code>parentNode</code> 속성을 가지고 있다. 부모 노드는 그룹이 생성될 때 설정된다. 그래서 <code>d3.selectAll("tr")&#8203;.selectAll("td")</code>를 호출하면 부모가 tr 인 td 문서요소들을 원소로 하는 그룹의 배열이 셀렉션으로 반환된다. d3.select 와 d3.selectAll 에 의해 반환되는 셀렉션은 <a href="https://developer.mozilla.org/en-US/docs/DOM/document.documentElement">document 요소</a>를 <code>parentNode</code> 속성으로 가지는 그룹의 배열이다.

<p class='d3-en'>Most of the time, you can safely ignore that selections are grouped. When you use a function to define a selection.attr or selection.style, the function is called for each element; the main difference with grouping is that the second argument to your function (<code>i</code>) is the within-group index rather than the within-selection index.</p>

<p>대부분의 경우 셀렉션이 그룹의 배열이라는 점을 인식하지 못해도 괜찮다. selection.attr 이나 selection.style 을 정의하기 위해 함수를 호출하면, 함수의 파라미터로 전달되는 내용은 셀렉션의 최말단 문서요소에 적용되기 때문이다. 그룹과 관련해 의식해야 할 것은, 함수의 두 번째 파라미터로 전달하는 (<code>i</code>)가 셀렉션 범위의 인덱스가 아니라 그룹 내에서의 인덱스라는 점이다.

<!-- The killer feature for groups is <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-data">selection.data</a>, which allows you to define data per-group (rather than for the entire selection), and thus more easily create hierarchical DOM elements from hierarchical data. We’ll revisit this topic when we get to data joins. -->

<h2><a href="#non-grouping" name="non-grouping">#</a>그룹핑을 변경하지 않는 메서드들</h2>

<p class='d3-en'>Only selectAll has special behavior regarding grouping; <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-select">select</a> preserves the existing grouping. The select method differs because there is exactly one element in the new selection for each element in the old selection. Thus, select also propagates data from parent to child, whereas selectAll does not (hence the need for a data-join)!</p>

<p>그룹핑(역자 주 : 그룹은 셀렉션의 최말단 문서요소를 원소로 하는 배열을 말하며, 이 글에서 그룹핑은 그룹 배열의 원소 개수와 그룹 배열의 parentNode 속성을 말한다)에 관해서는 selectAll만 특이하게 동작한다(역자 주 : selectAll만 원래의 셀렉션에 있는 그룹 배열의 parentNode 속성을 변경한다); <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-select">select</a>는 원래의 셀렉션에 있는 그룹핑을 변경하지 않고 그대로 보존한다. select 메서드는 원래의 셀렉션의 최말단 문서요소 각각에 대해 단 하나씩의 문서요소만을 원소로 취하는 단 하나의 그룹 배열을 반환하기 때문에 selectAll과 다르게 동작한다. select는 원래 셀렉션의 데이터를 새로운 셀렉션에 물려주지만, selectAll은 물려주지 않는다(그래서 데이터-조인이 필요하다!).

<p class='d3-en'>The <a href="https://github.com/mbostock/d3/blob/master/src/selection/append.js">append</a> and <a href="https://github.com/mbostock/d3/blob/master/src/selection/insert.js">insert</a> methods are wrappers on top of select, so they also preserve grouping and propagate data. For example, given a document with four sections:</p>

<p><a href="https://github.com/mbostock/d3/blob/master/src/selection/append.js">append</a> 메서드와 <a href="https://github.com/mbostock/d3/blob/master/src/selection/insert.js">insert</a> 메서드는 select 메서드를 랩핑한 메서드로서, select 메서드와 마찬가지로 그룹핑을 그대로 보존하고 원래의 셀렉션에 있던 데이터를 새로운 셀렉션에 물려준다. 예를 들어, 4개의 section이 있는 문서의 경우:

<pre><code>d3.selectAll("section");</code></pre>

<script>

tree(
  {type: "selection", name: "selection", children: [
    {type: "array", name: "group", children: [
      {type: "element", name: "section"},
      {type: "element", name: "section"},
      {type: "element", name: "section"},
      {type: "element", name: "section"}
    ]}
  ]},
  24 * 4
);

</script>

<p class='d3-en'>If you append a paragraph element to each section, the new selection likewise has a single group with four elements:</p>

<p>각 section에 paragraph를 append 하면, append 메서드가 반환하는 새로운 셀렉션은 네 개의 원소를 가지는 한 개의 그룹 배열을 갖게 된다.

<pre><code>d3.selectAll("section").append("p");</code></pre>

<script>

tree(
  {type: "selection", name: "selection", children: [
    {type: "array", name: "group", children: [
      {type: "element", name: "p"},
      {type: "element", name: "p"},
      {type: "element", name: "p"},
      {type: "element", name: "p"}
    ]}
  ]},
  24 * 4
);

</script>

<p class='d3-en'>Note that the <code>parentNode</code> for this selection is still the document element because selection.selectAll has not been called to regroup the selection.</p>

<p>위에서 append 메서드가 반환하는 새로운 셀렉션에 있는 그룹의 <code>parentNode</code> 속성은 여전히 document 임을 기억하자. 셀렉션의 그룹핑을 변경하는 selection.selectAll은 호출된 적이 없기 때문이다.

<h2><a href="#null" name="null">#</a>Null 문서요소</h2>

<p class='d3-en'>Groups can contain nulls to indicate missing elements. Nulls are ignored for most operations; for example, D3 skips null elements when applying styles and attributes.</p>

<p>그룹은 문서요소가 없는 상태를 나타내기 위해 null을 포함할 수 있다. null은 대부분의 처리에서 무시된다; 예를 들어, D3는 스타일이나 속성값을 적용할 때 null 문서요소는 무시하고 지나가 버린다.

<p class='d3-en'>Null elements can occur when selection.select cannot find a matching element for the given selector. The select method must preserve the grouping structure, so it fills the missing slots with null. For example, if only the last two sections have asides:</p>

<p>null 문서요소는 selection.select 메서드가 해당 셀렉터에 매칭되는 문서요소를 찾을 수 없을 때 발생할 수 있다. select 메서드는 그룹핑 구조를 그대로 보존해야 하므로, 매칭되는 짝이 없는 곳은 null로 채운다. 예를 들어, 앞의 예제에서 4개의 section 중에서 두 개만 asice 를 가지고 있다면:

<pre><code>d3.selectAll("section").select("aside");</code></pre>

<aside>여기서 selection.node는 <code>selection[0][2]</code>를 반환한다. <code>selection[0][2]</code>가 null이 아닌 첫 번째 문서요소이기 때문이다.</aside>

<script>

tree(
  {type: "selection", name: "selection", children: [
    {type: "array", name: "group", children: [
      {type: "null", name: "null"},
      {type: "null", name: "null"},
      {type: "element", name: "aside"},
      {type: "element", name: "aside"}
    ]}
  ]},
  24 * 4
);

</script>

<p class='d3-en'>As with grouping, you can usually ignore null elements, but note their use in preserving the grouped structure of a selection and its within-group index.</p>

<p>그룹핑에 대해서는 보통 null 문서요소를 무시할 수 있지만, 셀렉션의 그룹 구조를 보존하는 데 null 문서요소가 사용된다는 점과 그룹 내에서의 인덱스에 대해서는 기억을 해두자.

<!-- <p>Null elements are critical when handling the result of a data join, which splits a selection into three parts: <i>enter</i>, <i>update</i> and <i>exit</i>. These three selections share the original selection’s structure, with null elements in-between. -->

<h2><a href="#data" name="data">#</a>데이터 바인딩</h2>

<p class='d3-en'>Perhaps surprisingly, data is <i>not</i> a property of the selection, but a property of its elements. This means that when you bind data to a selection, the data is stored in the DOM rather than in the selection: data is assigned to the <code>__data__</code> property of each element. If an element lacks this property, the associated datum is undefined. Data is therefore persistent while selections can be considered transient: you can reselect elements from the DOM and they will retain whatever data was previously bound to them.</p>

<p>놀랍겠지만, 데이터는 셀렉션의 속성이 <i>아니고</i>, 셀렉션의 최말단 문서요소들의 속성이다. 데이터를 셀렉션에 바인딩하면, 데이터는 셀렉션이 아니라 셀렉션의 최말단 DOM 문서요소에 저장된다는 말이다: 데이터는 각 문서요소의 <code>__data__</code>라는 속성에 할당된다. 어떤 문서요소가 <code>__data__</code> 속성을 가지고 있지 않으면, 그 문서요소에는 바인딩 된 데이터가 정의되어 있지 않은 것이다. DOM에서 문서요소를 다시 셀렉트 할 수 있으며, 셀렉트 된 해당 DOM 문서요소는 이전에 바인딩 된 데이터를 여전히 유지하고 있다. 따라서, 데이터는 지속성이 있지만(persistent), 셀렉션은 지속성이 없다(transient).

<aside>데이터가 문서요소의 속성이라는 것을 확인하려면, <a href="https://github.com/mbostock/d3/blob/master/src/selection/datum.js">selection.datum</a>에 있는 구현 내용을 참고한다.
</aside>

<p class='d3-en'>Data is bound to elements one of several ways:</p>

<ul class='d3-en'>

  <li>Joined to groups of elements via <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-data">selection.data</a>.</li>
  <li>Assigned to individual elements via <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-datum">selection.datum</a>.</li>
  <li>Inherited from a parent via append, insert, or select.</li>

</ul>

<p>데이터는 아래와 같은 방법으로 문서요소에 바인딩 될 수 있다:

<ul>

  <li><a href="https://github.com/mbostock/d3/wiki/Selections#wiki-data">selection.data</a>를 통해 최말단 문서요소의 그룹에 조인.</li>
  <li><a href="https://github.com/mbostock/d3/wiki/Selections#wiki-datum">selection.datum</a>를 통해 개별 최말단 문서요소에 직접 할당.</li>
  <li>append, insert, or select 메서드를 통해 원래의 셀렉션으로부터 상속.</li>

</ul>

<p class='d3-en'>While there is no reason to set the <code>__data__</code> property directly when you can use selection.datum, doing so illustrates how data binding is implemented:</p>

<p>selection.datum을 사용할 수 있다면, <code>__data__</code> 속성에 직접 데이터를 할당할 일은 없겠지만, 데이터 바인딩이 어떻게 구현되었는지 설명하기 위해 직접 데이터를 할당하는 코드를 보면 다음과 같다:

<aside>브라우저의 개발자 도구에서 셀렉션을 검사할 때, <code>$0.__data__</code>를 실행하면 검사 중인 문서요소에 바인딩 된 데이터를 확인할 수 있다.</aside>

<pre><code>document.body.__data__ = 42;</code></pre>

<script>

tree(
  {type: "element", name: "body", children: [
    {type: "datum", name: "42"}
  ]},
  24 * 1
);

</script>

<p class='d3-en'>The D3-idiomatic equivalent is to select the body and call datum:</p>

<p>앞의 직접 데이터 할당과 동일한 D3의 구문은, body를 셀렉트 하고, call을 호출하는 것이다:

<pre><code>d3.select("body").datum(42);</code></pre>

<script>

tree(
  {type: "selection", name: "selection", children: [
    {type: "array", name: "group", children: [
      {type: "element", name: "body", children: [
        {type: "datum", name: "42"}
      ]}
    ]}
  ]},
  24 * 1
);

</script>

<p class='d3-en'>If we now append an element to the body, the child automatically inherits data from the parent:</p>

<p>body에 문서요소 하나를 추가하면, 추가된 문서요소는 body로 부터 자동으로 데이터를 물려 받는다:

<pre><code>d3.select("body").datum(42).append("h1");</code></pre>

<script>

tree(
  {type: "selection", name: "selection", children: [
    {type: "array", name: "group", children: [
      {type: "element", name: "h1", children: [
        {type: "datum", name: "42"}
      ]}
    ]}
  ]},
  24 * 1
);

</script>

<p class='d3-en'>And that brings us to the last method of binding data: the mysterious join! But before we can achieve enlightenment, we must answer a more existential question.</p>

<p>이것은 데이터 바인딩의 마지막 방식인 상속에 의한 방식이다. 데이터 바인딩에 대한 진정한 깨우침을 얻으려면, 좀 더 존재론적인 질문에 답을 할 수 있어야 한다.

<h2><a href="#data" name="data">#</a>데이터란 무엇인가?</h2>

<p class='d3-en'>Data in D3 can be any array of values. For example, an array of numbers:</p>

<p>D3에서 데이터란 숫자의 배열처럼, 값의 배열일 수 있다.

<pre><code>var numbers = [4, 5, 18, 23, 42];</code></pre>

<p class='d3-en'>Or an array of objects:</p>

<p>또는 객체의 배열일 수 있으며:

<aside><a href="http://alignedleft.com">Scott Murray</a>의 많은 튜토리얼 중의 하나가 D3에서 사용하는 <a href="http://alignedleft.com/tutorials/d3/data-types/">일반적인 데이터 타입</a>에 대해 자바스크립트로 설명하고 있다.</aside>

<pre><code>var letters = [
  {name: "A", frequency: .08167},
  {name: "B", frequency: .01492},
  {name: "C", frequency: .02780},
  {name: "D", frequency: .04253},
  {name: "E", frequency: .12702}
];</code></pre>

<p class='d3-en'>Even an array of arrays:</p>

<p>심지어 배열의 배열일 수도 있다:

<pre><code>var matrix = [
  [ 0,  1,  2,  3],
  [ 4,  5,  6,  7],
  [ 8,  9, 10, 11],
  [12, 13, 14, 15]
];</code></pre>

<p class='d3-en'>We can mirror the visual representation of selections to represent data. Here’s a plain array of five numbers:</p>

<p>지금까지 봐왔던 셀렉션의 시각적 표현과 대칭으로 데이터를 표시할 수 있다. 5개의 숫자로 이루어진 일반적인 배열을 생각해보자:

<script>

tree(
  null,
  {type: "array", name: "array", children: [
    {type: "datum", name: "4"},
    {type: "datum", name: "5"},
    {type: "datum", name: "18"},
    {type: "datum", name: "23"},
    {type: "datum", name: "42"}
  ]},
  24 * 5
);

</script>

<p class='d3-en'>Just as selection.style takes either a constant string to define a uniform style property (<i>e.g.</i>, <code>"red"</code>) for every selected element, or a function to compute a dynamic style per-element (<code>function(d) { return d.color; }</code>), <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-data">selection.data</a> can accept either a constant value or a function.</p>

<p>selection.style이 셀렉트 된 모든 문서요소에 단일 스타일 속성을 정의하기 위해 문자열 상수(<i>예를 들면</i>, <code>"red"</code>)를 사용하거나, 문서요소 별로 동적인 스타일을 계산하기 위해 함수(<code>function(d) { return d.color; }</code>)를 사용하는 것과 마찬가지로, <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-data">selection.data</a>도 상수값이나 함수를 인자로 사용할 수 있다.

<p class='d3-en'>However, unlike the other selection methods, <b>selection.data defines data per-group rather than per-element</b>: data is expressed as an array of values for the group, or a function that returns such an array. Thus, a <a href="#group">grouped</a> selection has correspondingly grouped data!</p>

<p>하지만 다른 selection 메서드와 달리, <b>selection.data는 데이터를 문서요소 단위로 정의하지 않고 그룹 단위로 정의한다</b>: 데이터는 그룹에 대한 배열로 표현되거나, 그런 배열을 반환하는 함수로 표현된다. 그래서 <a href="#group">그룹</a> 셀렉션은 그에 상응하는 그룹 데이터를 갖게 된다.

<aside>셀렉션에 4개의 그룹이 있으므로, data 함수는 4번 호출되고, 4개의 배열(각 호출마다 하나씩)을 반환한다. 반환된 각 배열은 여기서는 우연히 4개의 값을 갖고 있지만, 반환된 배열은 데이터에 따라 그 길이는 다를 수도 있다.(역자 주 : 원문에는 각 array가 4개 씩의 데이터를 가지도록 그림이 그려져 있으나, 여기서 설명한대로 각 array는 그 길이가 다를 수도 있으므로, array마다 길이가 같다는 오해가 생기지 않도록 원문의 그림을 수정했다)</aside>

<script>

tree(
  null,
  {type: "data", name: "data", children: [
    {type: "array", name: "array", children: [
      {type: "datum", name: "0"},
      {type: "datum", name: "1"}      
    ]},
    {type: "array", name: "array", children: [
      {type: "datum", name: "2"},
      {type: "datum", name: "3"},
      {type: "datum", name: "4"},
      {type: "datum", name: "5"},
      {type: "datum", name: "6"},
      {type: "datum", name: "7"}
    ]},
    {type: "array", name: "array", children: [
      {type: "datum", name: "8"},
      {type: "datum", name: "9"},
      {type: "datum", name: "10"}      
    ]},
    {type: "array", name: "array", children: [
      {type: "datum", name: "11"},
      {type: "datum", name: "12"},
      {type: "datum", name: "13"},
      {type: "datum", name: "14"},
      {type: "datum", name: "15"}
    ]}
  ]},
  24 * 16
);

</script>

<p class='d3-en'>The blue lines in the diagram indicate that the <span style="display:inline-block;position:relative;width:55px;"><svg style="position:absolute;top:-17px;" class="node" width="55" height="22"><g transform="translate(1,1)" class="data"><rect rx="6" ry="6" width="53" height="20"/><text x="26" y="10" dy=".35em" text-anchor="middle">data</text></g></svg></span> function <i>returns</i> the linked array. Your data function is passed the datum of the group’s <code>parentNode</code> (<code>d</code>) and the group’s index (<code>i</code>), and returns whatever array of data you want to join to that group. Thus, data is typically expressed as a function of parent data, facilitating the creation of hierarchical DOM elements from hierarchical data.</p>

<p>다이어그램에서 파란선은 <span style="display:inline-block;position:relative;width:55px;"><svg style="position:absolute;top:-17px;" class="node" width="55" height="22"><g transform="translate(1,1)" class="data"><rect rx="6" ry="6" width="53" height="20"/><text x="26" y="10" dy=".35em" text-anchor="middle">data</text></g></svg></span> 함수가 연결 배열(linked array)을 <i>반환</i>하는 것을 보여주고 있다. data 함수(역자 주 : selection.data 함수가 아니라 바인딩 할 데이터를 반환하는 함수. 즉, selection.data의 인자로 전달되는 함수)는 그룹의 <code>parentNode</code>의 데이터(<code>d</code>)와 그룹의 인덱스(<code>i</code>)를 인수로 전달 받아서, 그 그룹에 조인하고자 하는 데이터 배열을 반환한다. 따라서, 데이터는 부모 노드 데이터의 함수로 표현되어, 계층적인 데이터로부터 계층적인 DOM 문서요소를 쉽게 생성할 수 있다.

<p class='d3-en'>For selections with only a single group, you can pass the corresponding single array to selection.data directly; you only need a function when binding different data to different groups.</p>

<p>단 하나의 그룹을 가지는 셀렉션에 대해서는, 그에 상응하는 한 개의 배열을 selection.data에 직접 전달할 수도 있다; 각기 다른 데이터를 각기 다른 그룹에 바인딩 할 때만 함수가 필요하다.

<h2><a href="#key" name="key">#</a>깨우침을 향한 열쇠</h2>

<aside>(역자 주 : D3에서의 데이터 바인딩은 어떤 데이터를 문서요소의 __data__ 속성에 값으로 할당하는 것을 의미하며 기본적으로 값:값의 관계다.<br/>이에 반해 데이터 조인은, 데이터 배열을 셀렉션의 그룹 배열에 어떤 규칙을 가지고 접목하는 것으로 호스트 코드 상에서는 배열:배열의 관계다.<br/>데이터 조인은 데이터 바인딩의 한 방식이며, 데이터 조인을 하면 결과적으로 데이터 바인딩이 실행된다.)</aside>

<p class='d3-en'>To join data to elements, we must know which datum should be assigned to which element. This is done by pairing keys. A <i>key</i> is simply an identifying string, such as a name; when the key for a datum and an element are equal, the datum is assigned to that element.</p>

<p>데이터를 문서요소에 조인 시킬 때는 어떤 데이터가 어떤 문서요소에 할당되는 지 알아야 한다. 이를 위해 키(key)가 필요하다. <i>키</i>는 이름처럼 식별자로 사용되는 단순한 문자열이다; 데이터는 자신의 키 값과 같은 키 값을 가진 문서요소에 할당된다.

<p class='d3-en'>The simplest method of assigning keys is by index: the first datum and the first element have the key “0”, the second datum and element have the key “1”, and so on. Joining an array of numbers to a matching array of paragraph elements therefore looks like this, with keys shown in green:</p>

<p>키를 할당하는 가장 쉬운 방법은 인덱스를 이용하는 것이다: 첫 번째 데이터와 첫 번째 문서요소의 인덱스 값은 모두 "0"이고, 두 번째 데이터와 두 번째 문서요소의 키 값은 "1", 세 번째는 "2" ... 와 같은 식이다. 숫자 배열을 인덱스를 기준으로 매칭되는 단락 문서요소의 배열에 조인하는 것이 바로 이 방식이다. 아래 그림에서 키는 녹색으로 표시되어있다.

<pre><code>var numbers = [4, 5, 18, 23, 42];</code></pre>

<script>

tree(
  {type: "selection", name: "selection", children: [
    {type: "array", name: "group", children: [
      {type: "element", name: "element", children: [{type: "key", name: "0", join: 0}]},
      {type: "element", name: "element", children: [{type: "key", name: "1", join: 0}]},
      {type: "element", name: "element", children: [{type: "key", name: "2", join: 0}]},
      {type: "element", name: "element", children: [{type: "key", name: "3", join: 0}]},
      {type: "element", name: "element", children: [{type: "key", name: "4", join: 0}]}
    ]}
  ]},
  {type: "data", name: "data", children: [
    {type: "array", name: "array", children: [
      {type: "datum", name: "4", children: [{type: "key", name: "0"}]},
      {type: "datum", name: "5", children: [{type: "key", name: "1"}]},
      {type: "datum", name: "18", children: [{type: "key", name: "2"}]},
      {type: "datum", name: "23", children: [{type: "key", name: "3"}]},
      {type: "datum", name: "42", children: [{type: "key", name: "4"}]}
    ]}
  ]},
  24 * 5
);

</script>

<p class='d3-en'>The resulting selection now has elements bound to data:</p>

<p>아래와 같이 데이터 조인한 셀렉션에 있는 문서요소에는 데이터가 바인딩 되어 있다:

<pre><code>d3.selectAll("div").data(numbers);</code></pre>

<aside><a href="http://macwright.org/">Tom MacWright</a>의 "재미있고, 어려운" <a href="http://macwright.org/presentations/dcjq/">D3 소개</a>에서는 데이터 조인을 단순한 <a href="http://macwright.org/mistakes/#5010465" style="white-space:nowrap;">재구현</a>으로 설명한다.</aside>

<script>

tree(
  {type: "selection", name: "selection", children: [
    {type: "array", name: "group", children: [
      {type: "element", name: "div", children: [{type: "datum", name: "4"}]},
      {type: "element", name: "div", children: [{type: "datum", name: "5"}]},
      {type: "element", name: "div", children: [{type: "datum", name: "18"}]},
      {type: "element", name: "div", children: [{type: "datum", name: "23"}]},
      {type: "element", name: "div", children: [{type: "datum", name: "42"}]}
    ]}
  ]},
  24 * 5
);

</script>

<p class='d3-en'>Joining by index is convenient if your data and elements are in the same order. However, when orders differ, joining by index is insufficient! In this case, you can specify a <a href="../constancy/#key-functions">key function</a> as the second argument to selection.data. The key function returns the key for a given datum or element. For example, if your data is an array of objects, each with a <code>name</code> property, your key function can return the associated name:</p>

<p>데이터와 문서요소가 같은 순서로 되어 있다면, 인덱스에 의한 조인은 아주 편리하다. 하지만, 둘의 순서가 다를 경우 인덱스만으로는 부족하다! 이럴 때는 <a href="../constancy/#key-functions">키 함수</a>를 selection.data 의 두 번째 인자로 넘겨줘야 한다. 키 함수는 주어진 데이터나 문서요소의 키를 반환한다. 예를 들어, 데이터가 <code>name</code>이라는 속성을 가진 객체의 배열이면, 키 함수는 배열의 각 원소 객체의 name 을 반환한다:

<pre><code>var letters = [
  {name: "A", frequency: .08167},
  {name: "B", frequency: .01492},
  {name: "C", frequency: .02780},
  {name: "D", frequency: .04253},
  {name: "E", frequency: .12702}
];

function name(d) {
  return d.name;
}</code></pre>

<aside>키 함수는 원래 셀렉션의 최말단 문서요소와 조인할 새 데이터 각각에 대해 호출된다: 그래서 위 예제에서는 키 함수가 10번 호출된다. 이전에 이미 바인딩 된 데이터는 원래 키를 계산하는 데 사용되고, 새로운 데이터는 새로운 키를 계산하는 데 사용된다.</aside>

<script>

tree(
  {type: "selection", name: "selection", children: [
    {type: "array", name: "group", children: [
      {type: "element", name: "element", children: [{type: "key", name: "B", join: 1}]},
      {type: "element", name: "element", children: [{type: "key", name: "A", join: -1}]},
      {type: "element", name: "element", children: [{type: "key", name: "D", join: 1}]},
      {type: "element", name: "element", children: [{type: "key", name: "C", join: -1}]},
      {type: "element", name: "element", children: [{type: "key", name: "E", join: 0}]}
    ]}
  ]},
  {type: "data", name: "data", children: [
    {type: "array", name: "array", children: [
      {type: "code datum", name: "{name: \"A\"}", children: [{type: "key", name: "A"}]},
      {type: "code datum", name: "{name: \"B\"}", children: [{type: "key", name: "B"}]},
      {type: "code datum", name: "{name: \"C\"}", children: [{type: "key", name: "C"}]},
      {type: "code datum", name: "{name: \"D\"}", children: [{type: "key", name: "D"}]},
      {type: "code datum", name: "{name: \"E\"}", children: [{type: "key", name: "E"}]}
    ]}
  ]},
  24 * 5
);

</script>

<p class='d3-en'>Again, the selected elements are now bound to data. The elements have also been reordered within the selection to match the data:</p>

<p>셀렉트된 문서요소가 데이터에 바인딩 되었다: 문서요소들은 조인된 데이터에 맞게 셀렉션 내부에서 재정렬되었다.

<aside>셀렉션이 데이터와 조인되기는 했지만, 셀렉션에 포함된 문서요소들은 DOM 트리 상에서 자동으로 재정렬 되지는 <i>않는다</i>. DOM 트리 상에서 재정렬하려면 <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-order">selection.order</a> 또는 <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-sort">selection.sort</a> 를 호출해야 한다.</aside>

<pre><code>d3.selectAll("div").data(letters, name);</code></pre>

<script>

tree(
  {type: "selection", name: "selection", children: [
    {type: "array", name: "group", children: [
      {type: "element", name: "div", children: [{type: "code datum", name: "{name: \"A\"}"}]},
      {type: "element", name: "div", children: [{type: "code datum", name: "{name: \"B\"}"}]},
      {type: "element", name: "div", children: [{type: "code datum", name: "{name: \"C\"}"}]},
      {type: "element", name: "div", children: [{type: "code datum", name: "{name: \"D\"}"}]},
      {type: "element", name: "div", children: [{type: "code datum", name: "{name: \"E\"}"}]}
    ]}
  ]},
  24 * 5
);

</script>

<p class='d3-en'>This process can be quite complicated for large grouped selections, but is simplified somewhat because <b>each group is joined independently</b>. Thus, you only need to worry about unique keys within a group, not across the entire selection.</p>

<p>이런 절차는 대규모의 그룹이 포함된 셀렉션에서는 매우 복잡하게 진행되지만, <b>각 그룹 단위로 독립적으로 조인</b>되기 때문에 단순하게 볼 수도 있다. 그래서 키는 전체 셀렉션 내에서 유일할 필요가 없으며, 그룹 내에서만 유일성이 보장 되면 된다.

<script>

tree(
  {type: "selection", name: "selection", children: [
    {type: "array", name: "group", children: [
      {type: "element", name: "element", children: [{type: "key", name: "B", join: 1}]},
      {type: "element", name: "element", children: [{type: "key", name: "C", join: 1}]},
      {type: "element", name: "element", children: [{type: "key", name: "D", join: 1}]},
      {type: "element", name: "element", children: [{type: "key", name: "A", join: -3}]}
    ]},
    {type: "array", name: "group", children: [
      {type: "element", name: "element", children: [{type: "key", name: "A", join: 0}]},
      {type: "element", name: "element", children: [{type: "key", name: "B", join: 0}]},
      {type: "element", name: "element", children: [{type: "key", name: "D", join: 1}]},
      {type: "element", name: "element", children: [{type: "key", name: "C", join: -1}]}
    ]},
    {type: "array", name: "group", children: [
      {type: "element", name: "element", children: [{type: "key", name: "A", join: 0}]},
      {type: "element", name: "element", children: [{type: "key", name: "D", join: +2}]},
      {type: "element", name: "element", children: [{type: "key", name: "B", join: 0}]},
      {type: "element", name: "element", children: [{type: "key", name: "C", join: -2}]}
    ]},
    {type: "array", name: "group", children: [
      {type: "element", name: "element", children: [{type: "key", name: "C", join: +2}]},
      {type: "element", name: "element", children: [{type: "key", name: "D", join: +2}]},
      {type: "element", name: "element", children: [{type: "key", name: "A", join: -2}]},
      {type: "element", name: "element", children: [{type: "key", name: "B", join: -2}]}
    ]}
  ]},
  {type: "data", name: "data", children: [
    {type: "array", name: "array", children: [
      {type: "datum", name: "A", children: [{type: "key", name: "A"}]},
      {type: "datum", name: "B", children: [{type: "key", name: "B"}]},
      {type: "datum", name: "C", children: [{type: "key", name: "C"}]},
      {type: "datum", name: "D", children: [{type: "key", name: "D"}]}
    ]},
    {type: "array", name: "array", children: [
      {type: "datum", name: "A", children: [{type: "key", name: "A"}]},
      {type: "datum", name: "B", children: [{type: "key", name: "B"}]},
      {type: "datum", name: "C", children: [{type: "key", name: "C"}]},
      {type: "datum", name: "D", children: [{type: "key", name: "D"}]}
    ]},
    {type: "array", name: "array", children: [
      {type: "datum", name: "A", children: [{type: "key", name: "A"}]},
      {type: "datum", name: "B", children: [{type: "key", name: "B"}]},
      {type: "datum", name: "C", children: [{type: "key", name: "C"}]},
      {type: "datum", name: "D", children: [{type: "key", name: "D"}]}
    ]},
    {type: "array", name: "array", children: [
      {type: "datum", name: "A", children: [{type: "key", name: "A"}]},
      {type: "datum", name: "B", children: [{type: "key", name: "B"}]},
      {type: "datum", name: "C", children: [{type: "key", name: "C"}]},
      {type: "datum", name: "D", children: [{type: "key", name: "D"}]}
    ]}
  ]},
  24 * 16
);

</script>

<aside>키 함수에 대해서는 <a href="http://bost.ocks.org/mike/constancy/">객체 불변성</a>을 참고한다.</aside>

<p class='d3-en'>The above examples assume an exact 1:1 match between data and elements. But what happens when there’s no matching element for a given datum, or no matching datum for a given element?</p>

<p>앞의 예제는 데이터와 문서요소 사이에 정확히 1:1 관계가 성립한다. 하지만 주어진 데이터에 매칭되는 문서요소가 없거나, 반대로 주어진 문서요소에 매칭되는 데이터가 없는 경우에는 어떻게 처리될까?

<h2><a href="#enter-update-exit" name="enter-update-exit">#</a>Enter, Update, Exit</h2>

<p class='d3-en'>When joining elements to data by key, there are three possible logical outcomes:</p>

<ul class='d3-en'>

  <li><i>Update</i> - There was a matching element for a given datum.
  <li><i>Enter</i> - There was no matching element for a given datum.
  <li><i>Exit</i> - There was no matching datum for a given element.

</ul>

<p>키를 기준으로 문서요소를 데이터에 조인할 때는 논리적으로 다음과 같이 3가지 경우의 수가 있다:

<ul>

  <li><i>Update</i> - 주어진 데이터에 매칭되는 문서요소가 있는 경우
  <li><i>Enter</i> - 주어진 데이터에 매칭되는 문서요소가 없는 경우
  <li><i>Exit</i> - 주어진 문서요소에 매칭되는 데이터가 없는 경우

</ul>

<p class='d3-en'>These are the three selections returned by <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-data">selection.data</a>, <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-enter">selection.enter</a> and <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-exit">selection.exit</a>, respectively. To illustrate, imagine you had a bar chart of the first five letters of the alphabet (ABCDE), and you want to transition to your five favorite vowels (YEAOI). You can use a key function to maintain association of letters to bars across the transition, resulting in the following data join:</p>

<p>위에서 나열한 3가지 셀렉션은 각각 <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-data">selection.data</a>, <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-enter">selection.enter</a> and <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-exit">selection.exit</a>에 의해 반환된다. 설명을 위해, 알파벳의 첫 다섯 글자(ABCDE)로 된 막대 차트가 있다고 상상해보자. 이 차트를 다섯 개의 모음(YEAOI)으로 전이(transition, 역자 주 : 화면 상의 변화를 애니메이션을 통해 표시) 시키고 싶다고 하자. 이럴 때 키 함수를 사용해서 전이하는 동안 글자와 막대의 관계를 유지할 수 있다. 조인 결과는 다음과 같다:

<script>

tree(
  {type: "selection", name: "selection", children: [
    {type: "array", name: "group", children: [
      {type: "element", name: "element", children: [{type: "key", name: "A", join: 2}]},
      {type: "element", name: "element", children: [{type: "key", name: "B"}]},
      {type: "element", name: "element", children: [{type: "key", name: "C"}]},
      {type: "element", name: "element", children: [{type: "key", name: "D"}]},
      {type: "element", name: "element", children: [{type: "key", name: "E", join: -3}]}
    ]}
  ]},
  {type: "data", name: "data", children: [
    {type: "array", name: "array", children: [
      {type: "datum", name: "Y", children: [{type: "key", name: "Y"}]},
      {type: "datum", name: "E", children: [{type: "key", name: "E"}]},
      {type: "datum", name: "A", children: [{type: "key", name: "A"}]},
      {type: "datum", name: "O", children: [{type: "key", name: "O"}]},
      {type: "datum", name: "I", children: [{type: "key", name: "I"}]}
    ]}
  ]},
  24 * 5
);

</script>

<p class='d3-en'>Two of the previously-displayed letters (A and E) are vowels. These bars are therefore placed in the <b>update</b> selection, in order of the new data:</p>

<p>첫 다섯 글자 중에서 두 개(A와 E)는 모음이다. A와 E에 해당하는 막대는 매칭되는 짝이 있으므로 조인한 데이터의 순서에 맞게 <b>update</b> 셀렉션에 들어간다:

<pre><code>var div = d3.selectAll("div").data(vowels, name);</code></pre>

<aside>enter와 update 셀렉션은 새로운 데이터셋의 순서에 따라 정렬된다. update 셀렉션에서는 새로운 데이터가 원래의 데이터를 덮어쓴다.</aside>

<script>

updateAnimation(
  {type: "selection", name: "selection", children: [
    {type: "array", name: "group", children: [
      {type: "element", name: "element", children: [{type: "key", name: "A", join: 2}]},
      {type: "element", name: "element", children: [{type: "key", name: "B"}]},
      {type: "element", name: "element", children: [{type: "key", name: "C"}]},
      {type: "element", name: "element", children: [{type: "key", name: "D"}]},
      {type: "element", name: "element", children: [{type: "key", name: "E", join: -3}]}
    ]}
  ]},
  {type: "data", name: "data", children: [
    {type: "array", name: "array", children: [
      {type: "datum", name: "Y", children: [{type: "key", name: "Y"}]},
      {type: "datum", name: "E", children: [{type: "key", name: "E"}]},
      {type: "datum", name: "A", children: [{type: "key", name: "A"}]},
      {type: "datum", name: "O", children: [{type: "key", name: "O"}]},
      {type: "datum", name: "I", children: [{type: "key", name: "I"}]}
    ]}
  ]},
  {type: "selection", name: "selection", children: [
    {type: "array", name: "group", children: [
      {type: "null", name: "null"},
      {type: "element", name: "element", children: [{type: "datum", name: "E"}]},
      {type: "element", name: "element", children: [{type: "datum", name: "A"}]},
      {type: "null", name: "null"},
      {type: "null", name: "null"}
    ]}
  ]},
  24 * 5
);

</script>

<p class='d3-en'>The other three displayed letters (B, C and D) are consonants, and thus have no corresponding data in the new dataset. These elements are therefore placed in the <b>exit</b> selection. Note that the exit selection preserves the order of the original selection, which is sometimes useful when animating prior to removal:</p>

<p>나머지 세 개의 글자(B, C, D)는 자음이고, 새로운 데이터셋에 매칭되는 데이터가 없다. 세 개의 글자에 해당하는 문서요소들은 <b>exit</b> 셀렉션에 들어간다. exit 셀렉션은 원래 셀렉션의 순서를 그대로 보존한다는 점을 기억하자. exit 셀렉션에 있는 문서요소를 애니메이션 효과를 주면서 삭제할 때 유용하다:

<pre><code>div.exit();</code></pre>

<aside>exit 셀렉션은 원래 셀렉션에서의 순서, 인덱스, 데이터를 보존한다.</aside>

<script>

exitAnimation(
  {type: "selection", name: "selection", children: [
    {type: "array", name: "group", children: [
      {type: "element", name: "element", children: [{type: "key", name: "A", join: 2}]},
      {type: "element", name: "element", children: [{type: "key", name: "B"}]},
      {type: "element", name: "element", children: [{type: "key", name: "C"}]},
      {type: "element", name: "element", children: [{type: "key", name: "D"}]},
      {type: "element", name: "element", children: [{type: "key", name: "E", join: -3}]}
    ]}
  ]},
  {type: "data", name: "data", children: [
    {type: "array", name: "array", children: [
      {type: "datum", name: "Y", children: [{type: "key", name: "Y"}]},
      {type: "datum", name: "E", children: [{type: "key", name: "E"}]},
      {type: "datum", name: "A", children: [{type: "key", name: "A"}]},
      {type: "datum", name: "O", children: [{type: "key", name: "O"}]},
      {type: "datum", name: "I", children: [{type: "key", name: "I"}]}
    ]}
  ]},
  {type: "selection", name: "selection", children: [
    {type: "array", name: "group", children: [
      {type: "null", name: "null"},
      {type: "element", name: "element", children: [{type: "datum", name: "B"}]},
      {type: "element", name: "element", children: [{type: "datum", name: "C"}]},
      {type: "element", name: "element", children: [{type: "datum", name: "D"}]},
      {type: "null", name: "null"}
    ]}
  ]},
  24 * 5
);

</script>

<p class='d3-en'>Lastly, three of the vowels (Y, O and I) were not previously displayed, and thus have no corresponding element. These form the <b>enter</b> selection:</p>

<p>마지막으로 세 개의 모음(Y, O, I)는 화면에 표시되지 않는데, 매칭되는 문서요소가 없기 때문이다. 이 셋은 <b>enter</b> 셀렉션으로 들어간다:

<pre><code>div.enter();</code></pre>

<aside>enter 셀렉션 내에 있는 자리채우미(placeholders)는 일반적으로 지속성이 없다; enter 셀렉션은 enter.append 나 enter.insert 의 호출 결과로 나오는 셀렉션으로 대체된다.</aside>

<script>

enterAnimation(
  {type: "selection", name: "selection", children: [
    {type: "array", name: "group", children: [
      {type: "element", name: "element", children: [{type: "key", name: "A", join: 2}]},
      {type: "element", name: "element", children: [{type: "key", name: "B"}]},
      {type: "element", name: "element", children: [{type: "key", name: "C"}]},
      {type: "element", name: "element", children: [{type: "key", name: "D"}]},
      {type: "element", name: "element", children: [{type: "key", name: "E", join: -3}]}
    ]}
  ]},
  {type: "data", name: "data", children: [
    {type: "array", name: "array", children: [
      {type: "datum", name: "Y", children: [{type: "key", name: "Y"}]},
      {type: "datum", name: "E", children: [{type: "key", name: "E"}]},
      {type: "datum", name: "A", children: [{type: "key", name: "A"}]},
      {type: "datum", name: "O", children: [{type: "key", name: "O"}]},
      {type: "datum", name: "I", children: [{type: "key", name: "I"}]}
    ]}
  ]},
  {type: "selection", name: "selection", children: [
    {type: "array", name: "group", children: [
      {type: "element", name: "placeholder", children: [{type: "datum", name: "Y"}]},
      {type: "null", name: "null"},
      {type: "null", name: "null"},
      {type: "element", name: "placeholder", children: [{type: "datum", name: "O"}]},
      {type: "element", name: "placeholder", children: [{type: "datum", name: "I"}]}
    ]}
  ]},
  24 * 5
);

</script>

<p class='d3-en'>While update and exit are normal selections, enter is a subclass of selection. This is necessary because it represents elements that <i>do not yet exist</i>. An enter selection contains placeholders rather than DOM elements; these placeholders are simply objects with a <code>__data__</code> property. The implementation of <a href="https://github.com/mbostock/d3/blob/master/src/selection/enter-select.js">enter.select</a> is then specialized such that nodes are inserted into the group’s parent, replacing the placeholder. This is why it is critical to call selection.selectAll prior to a data join: it establishes the parent node for entering elements.</p>

<aside>(역자 주 : 이 문단의 후반부인 enter.select 이후의 내용은 문맥의 흐름과 맞지 않아서 차라리 무시하는 것이 enter, update, exit 셀렉션을 이해하는 데 도움이 된다.<br/>enter.select의 구현부에 대한 설명도 맞다고 보기 어려운 것이, 실제 소스를 보면 enter.select는 enter 셀렉션의 그룹의 parentNode 값과 enter 셀렉션의 그룹의 원소인 각 자리채우미의 __data__ 값을, enter.select가 반환할 새로운 셀렉션의 그룹의 parentData와 그룹의 원소의 __data__에 할당하고, 그 새로운 셀렉션을 반환할 뿐, 노드가 그룹의 부모로 삽입된다는 로직은 없다.<br/>마지막 문장 역시, enter 셀렉션에 대해 이야기하다가 왜 갑자기 그냥 selectAll도 아니고 selection.selectAll에 대해 이야기 하는 지 이해하기 어렵다.)</aside>

<p>update 셀렉션과 exit 셀렉션이 보통 셀렉션이지만, enter 셀렉션은 셀렉션의 서브클래스다. enter 셀렉션은 <i>아직 존재하지도 않는</i> 문서요소를 나타내기 때문에 보통 셀렉션과는 다를 수 밖에 없다. enter 셀렉션은 DOM 문서요소가 아니라 자리채우미(placeholder)를 포함한다; 자리채우미는 <code>__data__</code> 속성만을 가지는 단순 객체다. <a href="https://github.com/mbostock/d3/blob/master/src/selection/enter-select.js">enter.select</a>은 노드가 자리채우미를 대체하면서 그룹의 부모로 삽입되도록 특별하게 구현되어 있다. 바로 이 점이 데이터 조인을 하기 전에 selection.selectAll을 호출해야 하는 이유다: selection.selectAll은 새로운 enter 셀렉션의 parentNode를 정확하게 설정한다.

<h2><a href="#enter-update" name="enter-update">#</a>Enter와 Update 합치기</h2>

<p class='d3-en'>The <a href="http://bl.ocks.org/mbostock/3808218">general update pattern</a> with a data join appends entering elements and removes exiting elements, while modifying dynamic attributes, styles and other properties of updating elements. Often, there’s overlap between properties of updating and entering elements.</p>

<p>데이터 조인에 관한 <a href="http://bl.ocks.org/mbostock/3808218">update 일반 패턴</a>은 update 셀렉션에 있는 문서요소의 속성, 스타일 등을 수정하고, enter 셀렉션에 있는 문서요소를 추가하고, exit 셀렉션에 있는 문서요소를 제거한다. update 셀렉션에 있는 문서요소의 속성과 entering 셀렉션에 있는 문서요소의 속성이 겹치는 경우도 발생할 수 있다.

<p class='d3-en'>To reduce duplicate code, enter.append has a convenient side-effect: it replaces null elements in the update selection with the newly-created elements from the enter selection. Thus, after enter.append, the update selection is modified to contain both entering and updating elements. The update selection subsequently contains all currently-displayed elements:</p>

<p>코드 중복을 줄이기 위해, enter.append 에는 편리한 기능이 포함되어 있다: enter.append 는 update 셀렉션에 있는 null 문서요소를 enter 셀렉션에 있는 새로 생성된 문서요소로 대체한다. 그래서 enter.append 를 실행하고 나면, update 셀렉션은 enter 셀렉션에 있는 문서요소와 update 셀렉션에 있는 문서요소를 모두 포함하게 된다. 결과적으로 update 셀렉션은 현재 표시되는 모든 문서요소를 포함하게 된다:

<script>

tree(
  {type: "selection", name: "selection", children: [
    {type: "array", name: "group", children: [
      {type: "element", name: "element", children: [{type: "datum", name: "A"}]},
      {type: "element", name: "element", children: [{type: "datum", name: "E"}]},
      {type: "element", name: "element", children: [{type: "datum", name: "I"}]},
      {type: "element", name: "element", children: [{type: "datum", name: "O"}]},
      {type: "element", name: "element", children: [{type: "datum", name: "U"}]}
    ]}
  ]},
  24 * 5
);

</script>

<p class='d3-en'>With the selection once again consistent with the document, the life-cycle of the data join is complete.</p>

<p>셀렉션과 문서의 일관성이 다시 한 번 맞춰지면서, 데이터 조인의 생명주기가 완성된다.

<h3 style="margin-top:8em;">도움 주신 분들</h3>

<p class='d3-en'>Thank you to Anna Powell-Smith, Scott Murray, Nelson Minar, Tom Carden, Shan Carter, Jason Davies, Tom MacWright and John Firebaugh for reviewing and providing feedback to improve this article.</p>

<p>이 글을 리뷰해주시고 개선을 위한 값진 피드백을 보내주신 Anna Powell-Smith, Scott Murray, Nelson Minar, Tom Carden, Shan Carter, Jason Davies, Tom MacWright and John Firebaugh에게 감사의 말씀을 전한다.

<h3>더 읽을거리</h3>

<p class='d3-en'>If you found this article informative, if you found parts unclear or confusing, or if you have followup questions or feedback, please let me know via <a href="https://twitter.com/mbostock">Twitter</a> or <a href="https://news.ycombinator.com/item?id=5614421">Hacker News</a>. To continue learning about selections, <a href="https://github.com/mbostock/d3/tree/master/src/selection/">reading D3’s source</a> is a rigorous way to test your understanding. And here are several excellent talks and tutorials by others:

<ul class='d3-en'>
  <li><a href="http://alignedleft.com/tutorials/d3/binding-data/">Binding Data</a> by Scott Murray</li>
  <li><a href="http://www.rvl.io/annaps/d3-journey-to-the-source/">Journey to the Source</a> by Anna Powell-Smith</li>
  <li><a href="http://macwright.org/presentations/dcjq/">A Fun, Difficult Introduction to D3</a> by Tom MacWright</li>
</ul>
</p>

<p>이 글이 유익하다고 생각되거나, 명확하지 않거나 혼동스러운 부분이 있거나, 추가 질문이나 피드백이 있다면, <a href="https://twitter.com/mbostock">트위터</a> 나 <a href="https://news.ycombinator.com/item?id=5614421">Hacker News</a>를 통해 연락주기 바란다. 셀렉션에 대해 계속 공부하고 싶다면, <a href="https://github.com/mbostock/d3/tree/master/src/selection/">D3 소스 보기 - 셀렉션</a>을 보면 셀렉션에 대해 얼마나 이해하고 있는 지 엄격하게 테스트 해 볼 수 있다. D3에 대해 다른 사람들이 작성한 훌륭한 이야기거리와 튜토리얼은 아래와 같다:

<ul>
  <li><a href="http://alignedleft.com/tutorials/d3/binding-data/">데이터 바인딩</a> by Scott Murray
  <li><a href="http://www.rvl.io/annaps/d3-journey-to-the-source/">D3 소스로의 여행</a> by Anna Powell-Smith
  <li><a href="http://macwright.org/presentations/dcjq/">재미있고 어려운 D3 소개</a> by Tom MacWright
</ul>

<footer>
  <aside>April 26, 2013</aside>
  <a href="http://bost.ocks.org/mike/" rel="author">Mike Bostock</a>, 원문 : <a href="http://bost.ocks.org/mike/selection/" target="_blank">How Selections Work</a><br/>  
  2014년 11월 11일, 번역 : <a href="https://www.facebook.com/hanmomhanda" rel="author" target="_blank">오명운</a>&nbsp;&nbsp;&nbsp;
  <span class='d3-toggle showEN'>원문 함께 보기</span>&nbsp;&nbsp;&nbsp;<span class='d3-toggle onlyKR'>한글만 보기</span>
  <hr/>
  <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="크리에이티브 커먼즈 라이선스" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br /><a xmlns:cc="http://creativecommons.org/ns#" href="http://hanmomhanda.github.io/doc-translations/d3/How-Selections-Work.html" property="cc:attributionName" rel="cc:attributionURL"><a href='https://www.facebook.com/hanmomhanda' target='_blank'>hanmomhanda</a></a>의 저작물인 이 저작물은(는) <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">크리에이티브 커먼즈 저작자표시-비영리-동일조건변경허락 4.0 국제 라이선스</a>에 따라 이용할 수 있습니다.<br /><a xmlns:dct="http://purl.org/dc/terms/" href="http://bost.ocks.org/mike/selection/" rel="dct:source">http://bost.ocks.org/mike/selection/</a>의 저작물에 기반
</footer>

<!-- You found me! -->
<table style="position:absolute;top:-1000px;">
  <tr>
    <td><span>0</span></td>
    <td><span>1</span></td>
    <td><span>2</span></td>
    <td><span>3</span></td>
  </tr>
  <tr>
    <td><span>4</span></td>
    <td><span>5</span></td>
    <td><span>6</span></td>
    <td><span>7</span></td>
  </tr>
  <tr>
    <td><span>8</span></td>
    <td><span>9</span></td>
    <td><span>10</span></td>
    <td><span>11</span></td>
  </tr>
  <tr>
    <td><span>12</span></td>
    <td><span>13</span></td>
    <td><span>14</span></td>
    <td><span>15</span></td>
  </tr>
</table>

<footer style="position:absolute;top:-1000px;">
  <section></section>
  <section></section>
  <section><aside>Hello!</aside></section>
  <section><aside>There!</aside></section>
</footer>

<footer style="position:absolute;top:-1000px;">
  <div></div>
  <div></div>
  <div></div>
  <div></div>
  <div></div>
</footer>

<script>

console.warn("Hooray, you opened the JavaScript console. Have fun!");

</script>
<script>

GoogleAnalyticsObject = "ga", ga = function() { ga.q.push(arguments); }, ga.q = [], ga.l = +new Date;
ga("create", "UA-48272912-3", "ocks.org");
ga("send", "pageview");

</script>
<script async src="http://bost.ocks.org/mike/highlight.min.js"></script>
<script async src="//www.google-analytics.com/analytics.js"></script>
<!-- added by hanmomhanda -->
<script>
var enToggler = d3.selectAll('.showEN'),
    krToggler = d3.selectAll('.onlyKR'),
    enList = document.querySelectorAll('.d3-en'),
    i = j = enList.length,
    toggleEN = 0, toggleKR = 0;
enToggler.on('click', function () {
    if (!toggleEN) {
        while ( i-- ) {
            enList[i].style.display = 'block';
        }
        toggleEN++;
        i = enList.length;
    }    
});

krToggler.on('click', function () {
    if (toggleEN) {
        while ( j-- ) {
            enList[j].style.display = 'none';
        }
        toggleEN--;
        j = enList.length;  
    }    
});
</script>
<!-- added by hanmomhanda -->
